#!/usr/bin/env ruby

cycle = 1
srhash = {}
srmaxhash = {}
phase = 'none'

def handle_suspend_resume(line, srhash, cycle)
  timestamp, step, id, stage = line.match(/^ *.* \[\d{3}\] .... *(\d{1,6}\.\d{6}): suspend_resume: (.*)\[(\d*)\] (.*)/).captures
  return if step == 'timekeeping_freeze'

  step = "#{step}_#{id}" if %w(CPU_ON CPU_OFF).include? step
  k = "#{step}_#{cycle}"

  if stage == 'begin'
    srhash[k] = timestamp
  else
    cost = (timestamp.to_f - srhash[k].to_f) * 1000
    srhash[k] = cost
  end

  case step
  when 'suspend_enter'
    srhash["suspend_overall_#{cycle}"] = timestamp if stage == 'begin'
  when 'machine_suspend'
    handle_machine_suspend(stage, timestamp, srhash, cycle)
  when 'thaw_processes'
    handle_thaw_processes(stage, timestamp, srhash, cycle)
  when /^dpm_(.*)$/
    handle_dpm(stage, $1)
  end
end

def handle_machine_suspend(stage, timestamp, srhash, cycle)
  if stage == 'begin'
    cost = (timestamp.to_f - srhash["suspend_overall_#{cycle}"].to_f) * 1000
    srhash["suspend_overall_#{cycle}"] = cost.to_i
  else
    srhash["resume_overall_#{cycle}"] = timestamp
  end
end

def handle_thaw_processes(stage, timestamp, srhash, cycle)
  return unless stage == 'end'

  cost = (timestamp.to_f - srhash["resume_overall_#{cycle}"].to_f) * 1000
  srhash["resume_overall_#{cycle}"] = cost.to_i
end

while (line = $stdin.gets)
  line.chomp!
  case line
  when /^ *.* \[\d{3}\] .... *(\d{1,6}\.\d{6}): suspend_resume: (.*)\[(\d*)\] (.*)/
    handle_suspend_resume(line, srhash, cycle)
  when /^ *.* \[\d{3}\] .... *(\d{1,6}\.\d{6}): device_pm_callback_start: (.*) (.*), parent: .*$/
    timestamp, bus, device = line.match(/^ *.* \[\d{3}\] .... *(\d{1,6}\.\d{6}): device_pm_callback_start: (.*) (.*), parent: .*$/).captures
    id = "#{bus}_#{device}".tr(' ', '_')
    k = "#{id}_#{phase}_#{cycle}"
    srhash[k] = srhash.key?(k) ? -1 : timestamp
  when /^ *.* \[\d{3}\] .... *(\d{1,6}\.\d{6}): device_pm_callback_end: (.*) (.*), err=(\d?)/
    timestamp, bus, device = line.match(/^ *.* \[\d{3}\] .... *(\d{1,6}\.\d{6}): device_pm_callback_end: (.*) (.*), err=(\d?)$/).captures
    device.strip!
    id = "#{bus}_#{device}".tr(' ', '_')
    kmax = "#{id}_#{phase}"
    k = "#{kmax}_#{cycle}"
    if srhash[k] != -1
      cost = (timestamp.to_f - srhash[k].to_f) * 1000
      srhash[k] = cost.to_i
      srmaxhash[kmax] = 0 if srmaxhash[kmax].nil?
      srmaxhash[kmax] = cost.to_i if srmaxhash[kmax] < cost.to_i
    end
  else
    next
  end
end

srhash.each do |kk, vv|
  case kk
  when /(.*)_\d*/
    kmax = $1
    next if srmaxhash.key?(kmax) && srmaxhash[kmax] < 50

    puts "#{kmax}: #{vv}"
  end
end
